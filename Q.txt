Questions from Multithreading- 
•	What are the new features introduced in java 6 for collection framework to have a better synchronization ConcurrentNavigableMap(its advantages), CopyOnWriteArrayList, CopyOnWrite-ArraySe is expected. It also comes under collection part. 
https://www.javacodegeeks.com/2014/11/multithreading-concurrency-interview-questions-answers.html
•	Callable and Future.
•	Thread Synchronization – expected the working of synchronized block and methods
•	Static vs Non-Static synchronization / locking.
•	All methods of thread.  Join, wait Notify, Notify all are mostly preferred.
•	Use of Volatile keyword
•	Immutability of objects – All aspects of immutable class and defensive copying. why do we need to create immutable class. 
•	Real life scenarios where thread priority, concurrency and thread pooling is asked in tricky manner
•	Atomic variables in synchronization. 
Executor f/w
Kind of thread pools
volatile v/s atomic
10. Explain Threading Pool in Executor framework?
11. Scenario: Suppose 10 threads process parallel if one thread is stop because of some exception all threads will stop automatically also if same thread is start all threads will be start how to do it?

Questions in collection – 
-->	Difference between ArrayList, linkedlist and  Vector - https://dzone.com/articles/arraylist-vs-linkedlist-vs
-->	Treeset, Hashset differences and internal functionality. -
	Internally Hashset uses HashMap, LinkedHashSet has a linked running through the entries of the HashMap while the TreeMap uses TreeMap which internally is a Red Black tree implementation.
	Since all three implements Set interface they can be used for common Set operations like not allowing duplicates but since HashSet, TreeSet and LinkedHashSet has there special feature which makes them appropriate in certain scenario. Because of sorting order provided by TreeSet, use TreeSet when you need a collection where elements are sorted without duplicates. HashSet are rather general purpose Set implementation, Use it as default Set implementation if you need a fast, duplicate free collection. LinkedHashSet is extension of HashSet and its more suitable where you need to maintain insertion order of elements, similar to List without compromising performance for costly TreeSet. Another use of LinkedHashSet is for creating copies of existing Set, Since LinkedHashSet preservers insertion order, it returns Set which contains same elements in same order like exact copy. In short,  although all three are Set interface implementation they offer distinctive feature, HashSet is a general purpose Set while LinkedHashSet provides insertion order guarantee and TreeSet is a SortedSet which stores elements in sorted order specified by Comparator or Comparable in Java.
-->	Use of Collections (class) utility. - provides for immutable empty collections, unmodifiable collections, synchronized collections, binary search, min, max, reverse, shuffle, and sort
-->	Use of sorting techniques like comparable, comparator etc.
-->	Why to have equal and hashcode method overrides. - to serve the comparison/hashing purpose correctly
-->	what is the use of final keyword. - immutability
-->	What does below statement imply.(Internally how does it work with and without final keyword )
	final Emp e= new Emp(); - create a new object on heap, assign a reference to the location of the memory address and this reference is immutable due to final.
--> Already sorted Array. How to find  specific  number?--- Binary Search
--> Benefits of Concurrent #Map over #MAP.
	ConcurrentHashMap
	You should use ConcurrentHashMap when you need very high concurrency in your project.
	It is thread safe without synchronizing the whole map.
	Reads can happen very fast while write is done with a lock.
	There is no locking at the object level.
	The locking is at a much finer granularity at a hashmap bucket level.
	ConcurrentHashMap doesn’t throw a ConcurrentModificationException if one thread tries to modify it while another is iterating over it.
	ConcurrentHashMap uses multitude of locks.

	SynchronizedHashMap
	Synchronization at Object level.
	Every read/write operation needs to acquire lock.
	Locking the entire collection is a performance overhead.
	This essentially gives access to only one thread to the entire map & blocks all the other threads.
	It may cause contention.
	SynchronizedHashMap returns Iterator, which fails-fast on concurrent modification.
--> How to reduce the time complexity of O(n), if all elements are having the same hash code. We are free to choose any data structure. Use TreeMap which utilizes the Red Black tree and provides O(logn) complexity implementation for insertion and retrieval.
--> Reverse word in String. - split the string to an array, start from both ends and perform a swap until the middle of array is reached.
--> Sorting already sorted array the best option is to use Insertion sort since the time complexity comes down to O(n).
--> 1 Million numbers in Array .. how to sort this Array? If the range of numbers is small then we can use count sort. Another option is to use quicksort which does not have extra space requirements. If there is further space constraint then external sorting could be used.
	For external sorting we could use merge sort or heap sort.
	Inputs:  
	input_file  : Name of input file. input.txt
	output_file : Name of output file, output.txt
	run_size : Size of a run (can fit in RAM)
	num_ways : Number of runs to be merged
	Output:
	1) Read input_file such that at most 'run_size' elements
	   are read at a time. Do following for the every run read
	   in an array.
		  a) Sort the run using MergeSort.
		  b) Store the sorted run in a temporary file, say 'i' 
			 for i'th run.
	A simple solution is to create an output array of size n*k and one by one copy all arrays to it. Finally, sort the output array using any O(nLogn) sorting algorithm. This approach takes O(nkLognk) time.
	We can merge arrays in O(nk*Logk) time using Min Heap. Following is detailed algorithm.
	1. Create an output array of size n*k.
	2. Create a min heap of size k and insert 1st element in all the arrays into a the heap
	3. Repeat following steps n*k times.
		 a) Get minimum element from heap (minimum is always at root) and store it in output array.
		 b) Replace heap root with next element from the array from which the element is extracted. If the array doesn’t have any more elements, then replace root with infinite. After replacing the root, heapify the tree.

Questions from java.lang.String
--> StringBuilder and StringBuffer usage - synchronization and performance
-->	There is a file with some text in it. How to count the total no of Lines, words it. - Use LineNumberReader or user BufferedReader and count line.
-->	How to count the repeated words in a file. - read the file line by line, split each line by space delimiter and use a TreeMap to have the sorted keys which are individual tokens of the split array i.e. words and the value is the count.

JDBC
--> Advantage of having  Hibernate over JDBC and also possible sql injection security attacks. Object Mapping, Object based Query (HQL, JPQL), Lazy Loading, Caching, audit and versioning support

Miscellaneous:
--> How to calculate total count of users are visited to your website? Use HttpSessionListener and increment the count on each session creation. The count itself could be set in the servletcontext for access in other parts of the webapp.
--> Scenario: Suppose at time of xml parsing if you read name(in short form) ‘kk’ then in database you will write Kiran kumar how to do it? - Probably points to the usage of JAXBAdapter.
--> Out of Memory exception? How do you proceed for production issue? get the thread dump, - use jmap and jconsole to analyse the hprof (heapdump) file. <JAVA_HOME>/bin/jmap -dump:format=b,file=c:\temp\heap.hprof <PID>

Questions from database- 
--> Expect a very basic question on Joins. - Inner Join, Left, right and full,. The + symbol appears on the side which is not included in full.
--> Primary, Unique and foreign keys - http://sqlhints.com/2013/06/02/difference-between-primary-key-and-unique-key-in-sql-server/
-->	Difference in procedure and function.
	Function VS Procedure
	- Functions are typically used to return table variables. Stored procedures cant return table variables however, can create tables.
	- A procedure may or may not return multiple values. A function cannot return more than one value and has to return at least one value.
	- A function can only have IN parameters while stored procedures can have IN, OUT and INOUT parameters.
	- A FUNCTION always returns a value using the return statement while a PROCEDURE may return one or more values through parameters or may not return at all.
	- Functions can be used in select or update or delete statement while procedure can't.
	- Functions are normally used for computations where as procedures are normally used for executing business logic.
	- A Function returns 1 value only. Procedure can return multiple values.
	- Stored procedure is precompiled execution plan where as functions are not.
	http://www.interviewquestionspdf.com/2016/03/top-18-sql-stored-procedure-interview.html
-->	Use of triggers. 
	https://www.dotnetinterviewquestions.in/article_sql-server-interview-question-and-answers-triggers-instead-of-triggers-after-triggers-inserted-and-deleted-tables_128.html
	http://www.interviewquestionspdf.com/2016/03/top-22-sql-server-trigger-interview.html

--> Explain second level Cache? http://www.baeldung.com/hibernate-second-level-cache
--> tables emp and dept. Retrieve number of employees per department. group by department id count (emp.Id)
--> Removing duplicate records from table - 
	DELETE FROM your_table
	WHERE rowid not in
	(SELECT MIN(rowid)
	FROM your_table
	GROUP BY column1, column2, column3);
--> no. of emp. acc. to gender whose DOB is in b/w 1980-2000. - Use between operator with TO_DATE('', 'yyyy/mm/dd') function
--> All employees having salary higher than average salary. with t1 as (select avg(salary) avgsal from employee) select * from employee, t1 where salary > t1.avgsal

Questions from Spring
•	What is IOC and DI? 
•	Integration of REST and Spring.
•	Integration of Spring and Hibernate
•	Spring Security module- Authentication flow. 
•	Spring AOP- flow and use.

Java
Ice Cream Parlour design
Shopping Cart discount design
Execute a program to check heap state with all 4 GC algorithms

MAVEN
profile
multimodule
archetype
phases/lifecycle
test, code coverage
static code analysis

REST
application config to setup
error handling
API exposure
Session Management

@Contribution
JPA Standalone -  performance, query correctness
XML Generator
SVN Tagging utility
Service Virtualization
REST invoker from main
REST wrapper classes
Load balancing for REST URI
Error message replay

JSF
Debugging JSF phases
Managed bean v/s Backing bean
Lifecycle of JSF
Converter and Validator in JSF
JSF v/s GWT
